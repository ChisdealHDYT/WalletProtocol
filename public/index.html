<html class="main-html" lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SCP Wallet</title>

  <link rel="canonical" href="https://getbootstrap.com/docs/5.0/examples/carousel/">

  <link href="css/bootstrap.min.css" rel="stylesheet">
  <link href="css/style.css" rel="stylesheet">
  <link id="themeSheet" themeIndex="0" href="style/latest-style-light.css" rel="stylesheet">
  <link href="fontawesome/css/fontawesome.min.css" rel="stylesheet">
  <link href="fontawesome/css/all.min.css" rel="stylesheet">

  <!--- IMPORTANT: CHAIN PARAMS BELOW, DO NOT EDIT UNLESS YOU'RE ABSOLUTELY CERTAIN YOU KNOW WHAT YOU'RE DOING  --->
  <script>
    // In most BTC-derived coins, the below parameters can be found in the 'src/chainparams.cpp' Mainnet configuration.
    // These below params share the same names as the CPP params, so finding and editing these is easy-peasy!

    /* chainparams */
    const PUBKEY_ADDRESS = 125;
    const SCRIPT_ADDRESS = 117;
    const SECRET_KEY     = 253;

    // The amount of satoshis that make a full coin
    const COIN = 100000000;
  </script>
  
  <!-- Functional Libraries (Cryptography, Hashing, Encryption, Encoding, etc) -->
  <script type="text/javascript" src="../scripts/libs/aes-gcm.js"></script>
  <script type="text/javascript" src="../scripts/libs/crypto-min.js"></script>
  <script type="text/javascript" src="../scripts/libs/crypto-sha256.js"></script>
  <script type="text/javascript" src="../scripts/libs/crypto-sha256-hmac.js"></script>
  <script type="text/javascript" src="../scripts/libs/ripemd160.js"></script>
  <script type="text/javascript" src="../scripts/libs/jsbn.js"></script>
  <script type="text/javascript" src="../scripts/libs/ellipticcurve.js"></script>
  <script type="text/javascript" src="../scripts/libs/qrcode.js"></script>
  <script type="text/javascript" src="../scripts/libs/sha256.js"></script>

  <!-- Core Libraries (Script OPCodes, etc) -->
  <script type="text/javascript" src="../scripts/libs/core-lib/script.js"></script>

  <!-- Interface Framework Libraries (GUI, wallet management, networking, etc) -->
  <script type="text/javascript" src="../scripts/settings.js"></script>
  <script type="text/javascript" src="../scripts/wallet.js"></script>
  <script type="text/javascript" src="../scripts/network.js"></script>
  <script type="text/javascript" src="../scripts/bitTrx.js"></script>
  <script type="text/javascript" src="js/switchPages.js"></script>

  <!-- Materialize Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>

  <!-- SCP LIBRARY GOES BELOW -->
  <script type="text/javascript" src="../lib/index.js"></script>
  <!-- SCP LIBRARY GOES ABOVE -->

  <script>window.$ = window.jQuery = require('jquery');</script>
</head>

<body>
  <div id="loginPage" class="page-gradient" style="display: none;">
    <div class="container marketing">
      <div class="verticalalign" style="padding-top: 5%;">
        <div class="vertical-center color-white">
          <center>
            <img src="logo.svg" style="height:50px;">
            <i id="versionLogin" style="position: static;color: white;opacity: 0.6;font-size: small;cursor: default;letter-spacing: 1px;"></i>
            <br><br>
          </center>
            <div class="row">
              <div class="col-2"></div>
              <div class="col-8">
                <div class="login-card card-prop2 mb-4">
                  <div class="card-body font-gray">
                    <div class="login-page">
                      <center><h5 class="mb-3">Unlock your wallet</h5></center>

                      <span id="errMess"><br></span>
                      
                      <center>
                        <div class="omrs-input-group" style="width:100%; margin-bottom:10px;">
                          <label style="display: flex;" class="omrs-input-underlined">
                            <input required id="pass1" type="password" autofocus>
                            <span class="omrs-input-label">Password</span>
                            <button onclick="switchLoginVisibility()" style="background-color: transparent;border-style: none;outline: none;">
                              <i id="pass1Visibility" class="fas fa-eye-slash"></i>
                            </button>
                          </label>
                        </div>
                      </center>

                      <script>
                        function switchLoginVisibility() {
                          if (domPass1Visibility.classList.contains("fa-eye-slash")) {
                            // Display pass
                            domPass1Visibility.classList.remove("fa-eye-slash");
                            domPass1Visibility.classList.add("fa-eye");
                            document.getElementById("pass1").setAttribute("type", "text");
                          } else {
                            // Hide pass
                            domPass1Visibility.classList.remove("fa-eye");
                            domPass1Visibility.classList.add("fa-eye-slash");
                            document.getElementById("pass1").setAttribute("type", "password");
                          }
                        }

                        $(document).ready(function(){
                          $('#pass1').keypress(function(e){
                            if(e.keyCode==13) {
                              finishLogin();
                            }
                          });
                        });
                      </script>

                      <table class="mb-0" border="0">
                        <tr class="info">
                          <td>
                            <i class="fas fa-info-circle" style="margin-right: 10px;"></i>
                          </td>
                          <td>
                            Please remember to write down your password, if you lose it, StakeCube cannot recover your funds!
                          </td>
                        </tr>
                      </table>

                    </div>
                  </div>
                </div>
              </div>
              <div class="col-2"></div>
            </div>
        </div>
      </div>
    </div>
  </div>

  <Script>
    function finishLogin() {
      let nPass = document.getElementById("pass1").value;
      let nLoginError = document.getElementById("errMess");
      decryptWallet(nPass).then(done => {
        if (done) {
          nLoginError.innerHTML = "";
          document.getElementById("pass1").value = "";
          switchToDashboard();
          // Give the cache a kick
          setTimeout(() => {
            getBalance(true);
          }, 750);
          console.log("Login successful!");
        } else {
          M.toast({html: 'Incorrect Password!', displayLength: 2000});
        }
      });
    }
  </Script>

  <header id="guiHeader">
    <nav class="navbar navbar-expand-md navbar-dark fixed-top navbar-colour font-weight-bold">
      <div class="container-fluid">
        <a class="navbar-brand" href="#">
          <img onclick="switchToDashboard()" src="logo.svg" height="30">
          <i id="version" style="position: relative;color: white;opacity: 0.4;font-size: x-small;cursor: default;letter-spacing: 1px;bottom: -1px;"></i>
        </a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse"
          aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarCollapse">
          <ul class="navbar-nav me-auto mb-2 mb-md-0">
            <li class="nav-item">
              <a class="nav-link active" id="dashboardBtn" aria-current="page" href="#" onclick="switchToDashboard()">
                <i class="fas fa-tachometer-alt" style="margin-right: 5px;"></i>
                Dashboard
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="#" id="sendBtn" onclick="switchToSend()">
                <i class="fas fa-paper-plane" style="margin-right: 5px;"></i>
                Send
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="#" id="receiveBtn" onclick="switchToReceive()">
                <i class="fas fa-money-check" style="margin-right: 5px;"></i>
                Receive
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="#" id="2faBtn" onclick="switchToAuth()">
                <i class="fas fa-fingerprint" style="margin-right: 5px;"></i>
                2FA
              </a>
            </li>
          </ul>
        </div>
      </div>
    </nav>
  </header>

  <script>
    // GUI module imports
    const { clipboard } = require('electron');
    let authenticator = require("otplib").authenticator;

    // WALLET STATE DATA
    let cachedUTXOs = [];
    let cachedTokens = [];
    let cachedBlockCount = 0;
    let cachedActivity = [];

    // Privkey storage
    let privkeyDecrypted = null;
    let privkeyEncrypted = null;
    let pubkeyMain = null;

    // Statistical / Informational data
    let valueUSD = 0;
    let currentSupply = 0;

    // Cached DOM elements
    let domHeader;
    let domLoginPage;
    let domDashboardPage;
    let domSendPage;
    let domReceivePage;
    let domAuthPage;
    let domStakingPage;

    let domPass1Visibility;

    let domReceiveAddress;
    let domBalance;
    let domBalanceUSD;
    let domSendingBalance;
    let domActivityList;

    let domMarketcap;
    let domPrice;
    let domBlock;

    let domAuthDisplay;
    let domAuthImport;
    let domAuthTitle;
    let domAuthCode;
    let domAuthTime;
    let domAuthReset;

    let domStakingTitle;
    let domStakingSubtitle;
    let domStakingApy;
    let domStakingRewards;
    let domStakingRedeem;
    let domStakingRoi;

    function getSyncPercentage() {
      // We measure based on our total SCP hash-cache, and our blocks since the start of SCP
      if (cachedBlockCount === 0 || chainHashesCache.length === 0) return 0;
      if (!currentScanBlock || !currentScanBlock.height) return 100;
      return percentOf(chainHashesCache.length, (cachedBlockCount - nFirstBlock));
    }

    function getBalance(updateGUI = false) {
      let nBalance = 0;
      for (const nUTXO of cachedUTXOs) {
        // Calculate the balance from our UTXO cache
        nBalance += Number((nUTXO.satoshis / COIN).toFixed(8));
      }

      // Update the GUI too, if chosen
      if (updateGUI) {
        // --- Update SCC Balances
        // Set the balance, and adjust font-size for large balance strings
        domBalance.innerHTML = nBalance.toLocaleString('en-GB', { maximumFractionDigits: 8 });
        domBalance.style.fontSize = nBalance.toString().length > 8 ? "large" : "x-large";
        if (valueUSD > 0)
          domBalanceUSD.innerText = (nBalance * valueUSD).toFixed(2);
        // And update the Receive page pubkey
        domReceiveAddress.innerText = pubkeyMain;

        // --- Update SCP token balances
        // Fetch all tokens owned by our account (pubkeyMain)
        if (isFullnode)
          cachedTokens = TOKENS.getTokensByAccount(pubkeyMain);
        else
          getTokensByAccountLight(pubkeyMain);
        // Loop all tokens, construct an updated GUI for the Dashboard
        let dashboardTokens = document.getElementById("dashboardTokens");
        let sendTokensSelector = document.getElementById('sendingCoin');
        sendTokensSelector.innerHTML = '<option value="scc" data-thumbnail="circular-logo.png">StakeCubeCoin (SCC)</option>';
        dashboardTokens.innerHTML = '<div class="card-title font-gray font-weight-bold" style="margin-bottom:30px;">SCP Tokens</div>';
        if (chainHashesCache.length === 0 && isFullnode) {
          dashboardTokens.innerHTML += '<center><p>Loading SCP</p></center>';
        } else if (getSyncPercentage() < 99.99 && isFullnode) {
          dashboardTokens.innerHTML += '<center><p id="scpSyncing">SCP is still syncing (' + getSyncPercentage().toFixed(2) + '%)</p></center>';
        } else if (cachedTokens.length > 0) {
          for (const cToken of cachedTokens) {
            let stakingButton = 'onclick="switchToStaking(\'' + cToken.token.contract + '\')"';
            let stakingStyle = 'cursor:pointer;';
            let stakingText = '';
            if (cToken.token.version !== 2) {
              stakingButton = '';
              stakingStyle = '';
            } else {
              let nRewards = (cToken.account.unclaimed_balance / COIN);
              // Ensure we have unclaimed stakes, and the token has not hit max supply yet
              if (cToken.account.unclaimed_balance > 0 && (cToken.token.supply + cToken.account.unclaimed_balance) < cToken.token.maxSupply)
                stakingText = ' <i style="opacity:0.5;">(+' + (nRewards > 1 ? nRewards.toLocaleString('en-GB', { maximumFractionDigits: 4 }) : nRewards.toLocaleString('en-GB', { maximumFractionDigits: 8 })) + ')</i>';
            }
            dashboardTokens.innerHTML += '<div class="mt-3 mb-3 font-gray-2 font-weight-bold" style="font-size:15px;' + stakingStyle + '" ' + stakingButton + '><img src="circular-logo.png" style="width:32px; height:32px;"><span style="margin-left:10px;">' + cToken.token.name + '</span><span class="float-end">' + (cToken.account.balance / COIN).toLocaleString('en-GB', { maximumFractionDigits: 8 }) + stakingText + '</span></div>';
            sendTokensSelector.innerHTML += '<option value="scptoken-' + cToken.token.contract + '" data-thumbnail="circular-logo.png">' + cToken.token.name + ' (' + cToken.token.ticker + ')</option>';
          }
        } else {
          dashboardTokens.innerHTML += '<center><p>You have no tokens!</p></center>';
        }

        // Update activity widget
        if (isFullnode)
          cachedActivity = TOKENS.getActivityByAccount(pubkeyMain).reverse();
        else
          getActivityByAccountLight(pubkeyMain);
        if (cachedActivity.length > 0) {
          domActivityList.innerHTML = "";
          let amountToLoad = Math.min(cachedActivity.length, 5), i;
          for (i=0; i<amountToLoad; i++) {
            domActivityList.innerHTML += '<div class="mt-4"><div class="float-start text-center">Block ' + cachedActivity[i].block.toLocaleString('en-GB') + '</div><span class="float-end ' + ((cachedActivity[i].type === 'received' || cachedActivity[i].type === 'staked') ? "plus" : "minus") + '-balance-color font-weight-bold" style="position:relative; top:11px;"><i style="text-transform: capitalize;padding-right:5px;">' + cachedActivity[i].type + '</i> ' + ((cachedActivity[i].type === 'received' || cachedActivity[i].type === 'staked') ? "+" : "-") + (cachedActivity[i].amount / COIN).toLocaleString('en-GB', { maximumFractionDigits: 8, minimumFractionDigits: 2 }) + ' ' + cachedActivity[i].token.ticker + '</span></div><br><br>' + (i !== 4 ? '<hr style="margin-top:5px; margin-bottom:5px;" class="font-gray">' : '');
          }
        } else {
          domActivityList.innerHTML = "<center><p>You have no activity!</p></center>";
        }
      }

      return Number(nBalance.toFixed(8));
    }

    function getCachedToken(contract) {
      for (const cToken of cachedTokens) {
        if (cToken.token.contract === contract) return cToken.token;
      }
      return false;
    }

    function getCachedAccount(ctoken, address) {
      for (const account of ctoken.owners) {
        if (account.address === address) return account;
      }
      return false;
    }

    function sendTransactionGUI() {
      let coinSelection = document.getElementById("sendingCoinVal").value;
      let sendAmount = document.getElementById("sendAmount").value;
      let sendAddress = document.getElementById("sendAddress").value;
      if (coinSelection === "scc") {
        let nBalance = getBalance();
        if (sendAmount > nBalance) return M.toast({html: 'Not enough funds!', displayLength: 3000});
        console.log("Constructing TX of value: " + sendAmount + " SCC");
        // Loop our cached UTXOs and construct a TX
        trx = bitjs.transaction();
        let txValue = 0;
        for (const UTXO of cachedUTXOs) {
          if (txValue > sendAmount) {
            // Required Coin Control value met, yahoo!
            console.log("Coin Control: TX Constructed! Selected " + trx.inputs.length + " input(s) (" + txValue + " SCC)");
            break;
          }
          trx.addinput(UTXO.txid, UTXO.outputIndex, UTXO.script);
          txValue += Number((UTXO.satoshis / COIN).toFixed(8));
          txValue = Number(txValue.toFixed(8));
          console.log("Coin Control: Selected input " + UTXO.txid.substr(0, 6) + "(" + UTXO.outputIndex + ")... (Added " + (UTXO.satoshis / COIN).toFixed(8) + " SCC - Total: " + txValue + ")");
        }

        trx.addoutput(sendAddress, sendAmount); // Sending to this address
        calculatefee(trx.serialize().length);
        totalSent = (parseFloat(fee) + parseFloat(sendAmount)).toFixed(8);
        valuechange = (parseFloat(txValue) - parseFloat(totalSent)).toFixed(8);
        if (totalSent <= balance) {
          trx.addoutput(pubkeyMain, valuechange); // Change Output
          sendTransaction(trx.sign(privkeyDecrypted, 1));
        } else {
          console.warn("Amount: " + sendAmount + "\nFee: " + fee + "\nChange: " + valuechange + "\nTotal: " + totalSent);
          M.toast({html: 'You don\'t have enough SCC!', displayLength: 3000});
        }
      } else {
        let strToken = coinSelection.split('scptoken-')[1];
        let cToken = isFullnode ? TOKENS.getToken(strToken) : getCachedToken(strToken);
        let cAccount = isFullnode ? cToken.getAccount(pubkeyMain) : getCachedAccount(cToken, pubkeyMain);
        if ((cAccount.balance / COIN) < sendAmount) return M.toast({html: 'You don\'t have enough ' + cToken.ticker + '!', displayLength: 3000});
        if (cachedUTXOs.length === 0) return M.toast({html: 'You need SCC to pay for gas fees!', displayLength: 3000});
        console.log("Constructing SCP-" + cToken.version + " Transfer TX for: " + sendAmount + " " + cToken.name + " (" + cToken.contract + ")");
        // Use our first UTXO, as the fees will be incredibly low anyway
        trx = bitjs.transaction();
        let cUTXO;
        for (const cSelectedUTXO of cachedUTXOs) {
          cUTXO = cSelectedUTXO;
          if (cUTXO.satoshis > 200000) {
            trx.addinput(cUTXO.txid, cUTXO.outputIndex, cUTXO.script);
            break;
          }
        }
        trx.addoutputburn(0.00000001, cToken.contract + " send " + (sendAmount * COIN).toFixed(0) + " " + sendAddress); // Burn the transfer data on-chain

        calculatefee(trx.serialize().length);
        totalSent = parseFloat(fee).toFixed(8);
        valuechange = (parseFloat(cUTXO.satoshis / COIN) - parseFloat(totalSent)).toFixed(8);
        if (totalSent <= balance) {
          trx.addoutput(pubkeyMain, valuechange); // Change Output
          sendTransaction(trx.sign(privkeyDecrypted, 1));
        } else {
          console.warn("Transfer: " + sendAmount + " " + cToken.ticker + "\nFee: " + fee + " SCC\nChange: " + valuechange + " SCC\nTotal: " + totalSent + " SCC");
          M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
        }
      }
    }

    function claimStakingRewards(contract) {
        let cToken = isFullnode ? TOKENS.getToken(contract) : getCachedToken(contract);
        let cAccount = isFullnode ? cToken.getAccount(pubkeyMain) : getCachedAccount(cToken, pubkeyMain);
        if (cachedUTXOs.length === 0) return M.toast({html: 'You need SCC to pay for gas fees!', displayLength: 3000});
        console.log("Constructing SCP-" + cToken.version + " stake claim TX for " + (cAccount.unclaimed_balance / COIN).toLocaleString('en-GB') + " " + cToken.name + " (" + cToken.contract + ")");
        // Use our first UTXO, as the fees will be incredibly low anyway
        trx = bitjs.transaction();
        let cUTXO;
        for (const cSelectedUTXO of cachedUTXOs) {
          cUTXO = cSelectedUTXO;
          if (cUTXO.satoshis > 200000) {
            trx.addinput(cUTXO.txid, cUTXO.outputIndex, cUTXO.script);
            break;
          }
        }
        trx.addoutputburn(0.00000001, cToken.contract + " redeem");

        calculatefee(trx.serialize().length);
        totalSent = parseFloat(fee).toFixed(8);
        valuechange = (parseFloat(cUTXO.satoshis / COIN) - parseFloat(totalSent)).toFixed(8);
        if (totalSent <= balance) {
          trx.addoutput(pubkeyMain, valuechange); // Change Output
          sendTransaction(trx.sign(privkeyDecrypted, 1));
          domStakingRedeem.setAttribute('onclick', '');
          domStakingRedeem.classList.add('disabled');
          domStakingRedeem.innerText = 'Redeeming...';
          domStakingSubtitle.innerText = 'Your stake is being redeemed! Please wait until the next block to see your balance update.';
          M.toast({html: 'Redeeming, please wait for your claim to confirm on the network!', displayLength: 7500});
        } else {
          console.warn("Redeem: " + (cAccount.unclaimed_balance / COIN).toLocaleString('en-GB') + " " + cToken.ticker + "\nFee: " + fee + " SCC\nChange: " + valuechange + " SCC\nTotal: " + totalSent + " SCC");
          M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
        }
    }

    function deploySCP(version = 1, params = []) {
        if (!Number.isSafeInteger(version)) return console.error("SCP token must have a version integer!");
        if (params.length < 3) return console.error("SCP token deployment requires params!\nE.g; deploySCP(1, ['Cat Coin', 'CAT', " + COIN + "])");
        if (cachedUTXOs.length === 0) return M.toast({html: 'You need SCC to pay for gas fees!', displayLength: 3000});
        console.log("Constructing SCP-" + version + " deployment TX");
        // Use our first UTXO, as the fees will be incredibly low anyway
        trx = bitjs.transaction();
        let cUTXO;
        for (const cSelectedUTXO of cachedUTXOs) {
          cUTXO = cSelectedUTXO;
          if (cUTXO.satoshis > 200000) {
            trx.addinput(cUTXO.txid, cUTXO.outputIndex, cUTXO.script);
            break;
          }
        }
        trx.addoutputburn(0.00000001, "SCPCREATE" + version + " " + params.join(" "));

        calculatefee(trx.serialize().length);
        totalSent = parseFloat(fee).toFixed(8);
        valuechange = (parseFloat(cUTXO.satoshis / COIN) - parseFloat(totalSent)).toFixed(8);
        if (totalSent <= balance) {
          trx.addoutput(pubkeyMain, valuechange); // Change Output
          sendTransaction(trx.sign(privkeyDecrypted, 1));
          M.toast({html: 'Deploying! Please wait for the contract to confirm in a block!', displayLength: 7500});
        } else {
          console.warn("SCP-" + version + " Deployment:\nFee: " + fee + " SCC\nChange: " + valuechange + " SCC\nTotal: " + totalSent + " SCC");
          M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
        }
    }

    function mintSCP(contract, amount) {
        if (cachedUTXOs.length === 0) return M.toast({html: 'You need SCC to pay for gas fees!', displayLength: 3000});
        console.log("Constructing SCP mint TX for " + (amount / COIN).toLocaleString('en-GB'));
        // Use our first UTXO, as the fees will be incredibly low anyway
        trx = bitjs.transaction();
        let cUTXO;
        for (const cSelectedUTXO of cachedUTXOs) {
          cUTXO = cSelectedUTXO;
          if (cUTXO.satoshis > 200000) {
            trx.addinput(cUTXO.txid, cUTXO.outputIndex, cUTXO.script);
            break;
          }
        }
        trx.addoutputburn(0.00000001, contract + " mint " + amount);

        calculatefee(trx.serialize().length);
        totalSent = parseFloat(fee).toFixed(8);
        valuechange = (parseFloat(cUTXO.satoshis / COIN) - parseFloat(totalSent)).toFixed(8);
        if (totalSent <= balance) {
          trx.addoutput(pubkeyMain, valuechange); // Change Output
          sendTransaction(trx.sign(privkeyDecrypted, 1));
          M.toast({html: 'Minting, please wait for your mint to confirm on the network!', displayLength: 7500});
        } else {
          console.warn("Mint: " + (amount / COIN).toLocaleString('en-GB') + " tokens\nFee: " + fee + " SCC\nChange: " + valuechange + " SCC\nTotal: " + totalSent + " SCC");
          M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
        }
    }

    function autofillSendingAmount() {
      document.getElementById("sendAmount").value = domSendingBalance.innerText;
    }

    function refreshSyncStatus() {
      let domScpSyncing = document.getElementById("scpSyncing");
      let syncPercent = getSyncPercentage();
      if (syncPercent > 99.99) {
        // Sync is close enough to being finished, stop checking and load the tokens!
        clearInterval(syncStatusInterval);
        getBalance(true);
      }
      if (domScpSyncing) {
        domScpSyncing.innerText = 'SCP is still syncing (' + syncPercent.toFixed(2) + '%)';
      } else if (syncPercent > 0) {
        getBalance(true);
      }
    }

    let currentStakingToken = false;
    let guiStakingToken;
    let guiStakingAccount;
    let guiStakingStatus;
    function refreshStakingStatus(contract) {
      if (isFullnode) {
        guiStakingToken   = TOKENS.getToken(contract);
        guiStakingAccount = guiStakingToken.getAccount(pubkeyMain);
        guiStakingStatus  = guiStakingToken.getStakingStatus(pubkeyMain);
      } else {
        guiStakingToken   = getCachedToken(contract);
        guiStakingAccount = getCachedAccount(guiStakingToken, pubkeyMain);
        getStakingStatusLight(contract, pubkeyMain);
      }
      // Put token + account info on the Staking Page on this refresh!
      if ((guiStakingToken && guiStakingAccount && guiStakingStatus) && guiStakingStatus.enabled) {
        domStakingTitle.innerText = guiStakingToken.name + " " + guiStakingToken.ticker;
        // Run a quick'n'dirty APY calculation based on the current weight reward
        let nReward = guiStakingToken.inflation * guiStakingStatus.weight;
        // Also check to ensure we haven't hit the max supply yet
        if (guiStakingToken.supply === guiStakingToken.maxSupply ||
           (guiStakingToken.supply + guiStakingAccount.unclaimed_balance) >= guiStakingToken.maxSupply)
        {
          domStakingApy.innerText = "0%";
          domStakingRoi.innerText = "";
          domStakingSubtitle.innerText = guiStakingToken.name + " has hit it's max supply of " + (guiStakingToken.maxSupply / COIN).toLocaleString('en-GB') + " " + guiStakingToken.ticker  + "!";
          domStakingRewards.innerText = "Cap Reached";
          domStakingRedeem.setAttribute('onclick', '');
          if (!domStakingRedeem.classList.contains('disabled'))
            domStakingRedeem.classList.add('disabled');
          domStakingRedeem.innerText = 'No Stakes to Claim';
        } else {
          let nAPY = percentOf((nReward * 720) * 365, guiStakingAccount.balance);
          if (nAPY > 0.01 && nReward > 1) {
            domStakingApy.innerText = nAPY.toLocaleString('en-GB', { maximumFractionDigits: (nAPY > 100 ? 0 : 2) }) + "%";
            domStakingRoi.innerText = "or a ROI of " + percentOf(guiStakingAccount.unclaimed_balance, guiStakingAccount.balance).toFixed(2) + "%";
          } else {
            domStakingApy.innerText = "---";
            domStakingRoi.innerText = "";
          }
          domStakingSubtitle.innerHTML = "You've been staking for " + (guiStakingStatus.age - guiStakingToken.minAge).toLocaleString('en-GB') + " blocks and earned...";
          domStakingRewards.innerText = (guiStakingAccount.unclaimed_balance / COIN).toLocaleString('en-GB') + " " + guiStakingToken.ticker;
          if (guiStakingAccount.unclaimed_balance > 0) {
            domStakingRedeem.setAttribute('onclick', 'claimStakingRewards("' + contract + '")');
            domStakingRedeem.classList.remove('disabled');
            domStakingRedeem.innerText = 'Claim Rewards';
          } else {
            domStakingRedeem.setAttribute('onclick', '');
            if (!domStakingRedeem.classList.contains('disabled'))
              domStakingRedeem.classList.add('disabled');
            domStakingRedeem.innerText = 'No Stakes to Claim';
          }
        }
      } else if (guiStakingToken && guiStakingAccount && guiStakingStatus) {
        domStakingTitle.innerText = guiStakingToken.name + " (" + guiStakingToken.ticker + ")";
        domStakingApy.innerText = "---";
        domStakingRoi.innerText = "";
        domStakingSubtitle.innerHTML = "Your tokens need another " + (guiStakingToken.minAge - guiStakingStatus.age).toLocaleString('en-GB') + " blocks to mature before earning stakes!";
        domStakingRewards.innerHTML = (guiStakingAccount.unclaimed_balance / COIN).toLocaleString('en-GB') + " " + guiStakingToken.ticker;
        domStakingRedeem.setAttribute('onclick', '');
        if (!domStakingRedeem.classList.contains('disabled'))
          domStakingRedeem.classList.add('disabled');
        domStakingRedeem.innerText = 'No Stakes to Claim';
      } else {
        domStakingTitle.innerText = guiStakingToken ? guiStakingToken.name + " (" + guiStakingToken.ticker + ")" : "Loading...";
        domStakingApy.innerText = "---";
        domStakingRoi.innerText = "";
        domStakingSubtitle.innerHTML = "Loading...";
        domStakingRewards.innerHTML = "...";
        domStakingRedeem.setAttribute('onclick', '');
        if (!domStakingRedeem.classList.contains('disabled'))
          domStakingRedeem.classList.add('disabled');
        domStakingRedeem.innerText = 'No Stakes to Claim';
      }
    }

    function import2FA() {
      let strNewSecret = document.getElementById("authSecretImport").value;
      let testToken = authenticator.generate(strNewSecret);
      if (testToken && testToken.toString().length === 6) {
        localStorage.setItem("authsecret", strNewSecret);
      }
    }

    function remove2FA() {
      localStorage.removeItem("authsecret");
      refreshAuthenticator();
    }

    let lastAuthCode = null;
    function refreshAuthenticator() {
      let strSecret = localStorage.getItem("authsecret");
      if (!strSecret) {
        // No authentication linked
        domAuthImport.style.display = "";
        domAuthDisplay.style.display = "none";
        domAuthTitle.innerText = "Setup your 2FA";
        domAuthReset.style.display = "none";
      } else {
        // Auth code already imported
        domAuthImport.style.display = "none";
        domAuthDisplay.style.display = "";
        domAuthTitle.innerText = "Login using 2FA";
        domAuthReset.style.display = "";
        // Fetch the current code
        let authCode = authenticator.generate(strSecret);
        if (lastAuthCode !== authCode)
          domAuthCode.innerText = authCode;
        let authTimeRemaining = authenticator.timeRemaining()
        domAuthTime.innerText = authTimeRemaining + " second" + (authTimeRemaining === 1 ? "" : "s") + " remaining until next code";
        lastAuthCode = authCode;
      }

      // Also use this chance to update the Staking page, if it's open
      if (domStakingPage.style.display === "block" && currentStakingToken) {
        refreshStakingStatus(currentStakingToken);
      }
    }

    function copyToClipboard(text, name) {
      clipboard.writeText(text);
      M.toast({html: 'Copied ' + name + ' to Clipboard!', displayLength: 2000});
    }

    setInterval(() => {
      // Check block count + UTXO sync every 10 seconds
      getBlockCount();
      // Update Dashboard stats
      if (valueUSD > 0) {
        domBalanceUSD.innerText = (getBalance() * valueUSD).toFixed(2);
        domPrice.innerText = "$" + valueUSD.toFixed(2);
        if (currentSupply > 0)
          domMarketcap.innerText = "$" + (currentSupply * valueUSD).toLocaleString('en-GB', { maximumFractionDigits: 0});
      }
      // Fetch price and supply info
      getCoinValue();
      getCoinSupply();
    }, 10000);

    // Refresh syncing status
    let syncStatusInterval = setInterval(refreshSyncStatus, 200);

    // Refresh 2FA system
    setInterval(refreshAuthenticator, 1000);

    onload = () => {
      // Cache all our UI elements
      domTheme = document.getElementById("themeSheet");
      domThemeButton = document.getElementById("themeButton");
      // Initialize theme from disk
      loadTheme();
      domHeader = document.getElementById("guiHeader");
      domLoginPage = document.getElementById("loginPage");
      domPass1Visibility = document.getElementById("pass1Visibility");
      domDashboardPage = document.getElementById('dashboardPage');
      domSendPage = document.getElementById('sendPage');
      domReceivePage = document.getElementById('receivePage');
      domAuthPage = document.getElementById('authPage');
      domStakingPage = document.getElementById('stakingPage');
      domAuthDisplay = document.getElementById('authDisplay');
      domAuthImport = document.getElementById('authImport');
      domAuthTitle = document.getElementById('authTitle');
      domReceiveAddress = document.getElementById("receiveAddress");
      domAuthCode = document.getElementById("authCode");
      domAuthTime = document.getElementById("authTime");
      domAuthReset = document.getElementById("authReset");
      domBalance = document.getElementById("guiBalance");
      domBalanceUSD = document.getElementById("balanceUSD");
      domSendingBalance = document.getElementById("sendingCoinBalance");
      domPrice = document.getElementById("dashboardPrice");
      domMarketcap = document.getElementById("dashboardMarketcap");
      domBlock = document.getElementById("dashboardBlock");
      domDashboardBtn = document.getElementById("dashboardBtn");
      domActivityList = document.getElementById("activityList");
      domSendBtn = document.getElementById("sendBtn");
      domReceiveBtn = document.getElementById("receiveBtn");
      dom2FABtn = document.getElementById("2faBtn");
      domStakingTitle = document.getElementById("stakingTitle");
      domStakingSubtitle = document.getElementById("stakingSubtitle");
      domStakingApy = document.getElementById("stakingApy");
      domStakingRoi = document.getElementById("stakingRoi");
      domStakingRewards = document.getElementById("stakingRewards");
      domStakingRedeem = document.getElementById("stakingRedeem");
      // Don't need to cache these as it's just one-time use
      if (npm_package) {
        document.getElementById("version").innerText = "v" + npm_package.version;
        document.getElementById("versionLogin").innerText = "v" + npm_package.version;
      } else {
        document.getElementById("version").style.display = "none";
        document.getElementById("versionLogin").style.display = "none";
      }
      // Check for an encrypted wallet, if one exists, pull up the login screen!
      let encwif = localStorage.getItem("encwif");
      if (encwif && encwif.length > 1) {
        console.log("Encrypted key found: " + encwif);
        privkeyEncrypted = encwif;
        switchToLogin();
        // Focus on the password entry
        document.getElementById("pass1").focus();
      } else {
        // No privkey available, derive a new one and encrypt using the temppass
        let tmppass = localStorage.getItem("tmppass");
        if (!tmppass) throw "Unable to find encwif, and no tmppass available, bailing out!";
        console.log("Unable to find encrypted keys, but tmppass is available, deriving new key...");
        generateWallet().then(objWallet => {
          // Save decrypted copy in memory
          privkeyDecrypted = objWallet.privkey;
          // Encrypt wallet and save it to disk
          encryptWallet(tmppass).then(newEncwif => {
            console.log("Encrypted wallet!");
            console.log(newEncwif);
            console.log(tmppass);
            privkeyEncrypted = newEncwif;
            localStorage.setItem("encwif", privkeyEncrypted);
            // Erase the tmppass from disk and memory
            tmppass = null;
            localStorage.removeItem("tmppass");
            // Load the Dashboard screen
            switchToDashboard();
          });
        });
      }
    }
  </script>

  <main class="main-body">
    <div class="container marketing pt-navbar" id="dashboardPage">

      <h4 class="mb-5 theme-color-secondary font-weight-bold">Dashboard</h4>

      <div class="row">
        <div class="col-7">

          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold">Balance<span
                  id="balanceRefresh" onclick="getBlockCount(); getBalance(true);" class="float-end theme-color refresh-button reload"><i class="fas fa-redo-alt"></i></span></div>
              <div class="mt-4 theme-color-secondary font-weight-bold">
                <div class="float-end"><span id="guiBalance" class="font-balance">...</span> <span
                    class="font-size-ticker">SCC</span></div><br><br>
                <div class="float-end balance-usd-props"><span
                    id="balanceUSD" class="font-balance-usd font-gray font-weight-normal">...</span> <span
                    class="font-size-ticker-usd font-gray font-weight-normal">USD</span></div>
              </div>
            </div>
          </div>

          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold">Activity</div>
              <div id="activityList">
                <center><p>Loading Activity</p></center>
              </div>
            </div>
          </div>

        </div>
        <div class="col-5">

          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold">Overview</div>
              <div class="mt-4 theme-color-secondary font-weight-bold font-size-overview">
                <span class="font-gray">Price:</span>
                <span class="float-end" id="dashboardPrice">Loading...</span><br>
                <span class="font-gray">Marketcap:</span>
                <span class="float-end" id="dashboardMarketcap">Loading...</span><br>
                <span class="font-gray">Current Block:</span>
                <span class="float-end" id="dashboardBlock">Loading...</span>
              </div>
            </div>
          </div>

          <div class="card card-prop mb-4">
            <div id="dashboardTokens" class="card-body">
              <div class="card-title font-gray font-weight-bold" style="margin-bottom:30px;">SCP Tokens</div>
              <center><p>Loading SCP</p></center>
            </div>
          </div>

        </div>
      </div>


    </div>

    <div class="container marketing pt-navbar" id="sendPage">
      <h4 class="mb-5 theme-color-secondary font-weight-bold">Send</h4>

      <div class="row">
        <div class="col-2"></div>
        <div class="col-8">

          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold">Withdraw</div>

              <div class="alert alert-danger-custom" style="font-size:13px;"><i class="fas fa-exclamation-triangle"></i> &nbsp;Please make sure to enter the correct address. Transactions cannot be reversed.</div><br>

              <div class="row">
                <div class="col-6">
                  <select id="sendingCoin" class="vodiapicker">
                    <option value="" data-thumbnail="i.png" disabled selected hidden>-</option>
                    <option value="scc" data-thumbnail="circular-logo.png">StakeCubeCoin (SCC)</option>
                  </select>
                  <div class="lang-select">
                    <button id="sendingCoinVal" class="btn-select" value="scc"></button>
                    <div class="b" style="z-index:1000;">
                      <ul id="a"></ul>
                    </div>
                  </div>
                </div>
              </div><br>

              <div class="row">
                <div class="col-6">
                  <div class="omrs-input-group" style="width:100%; margin-bottom: 0px;">
                    <label class="omrs-input-underlined">
                      <input required id="sendAmount" type="text">
                      <span class="omrs-input-label">Amount</span>
                    </label>
                  </div>
                  <span style="font-size: 13px; top:5px; position: relative;">Available: <span id="sendingCoinBalance" onclick="autofillSendingAmount()" style="cursor: pointer;" class="badge badge-theme" style="margin-bottom:0px">-</label></span>
                </div>
                
                <div class="col-6">
                  <div class="omrs-input-group" style="width:100%;">
                    <label class="omrs-input-underlined">
                      <input required id="sendAddress" type="text">
                      <span class="omrs-input-label">SCC Address</span>
                    </label>
                  </div>
                </div>

                <div class="col text-end"><br>
                  <button class="btn btn-layout btn-theme" onclick="sendTransactionGUI()">Send Transaction</button><br>
                </div>
              </div>
            </div>
          </div>

        </div>
        <div class="col-2"></div>
      </div>

    </div>

    <div class="container marketing pt-navbar" id="receivePage">
      <h4 class="mb-5 theme-color-secondary font-weight-bold">Receive</h4>

      <div class="row">
        <div class="col-2"></div>
        <div class="col-8">

          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold">Receive address</div>
              <div class="alert alert-danger-custom" style="font-size:13px;"><i class="fas fa-exclamation-triangle"></i> Please make sure to only send SCC or SCP tokens to this address. Other coins will be lost and cannot be reversed.</div><br>
              
              <center>
                <div onclick="copyToClipboard(pubkeyMain, 'Address')" class="refresh-button hover-darker">
                  <span id="receiveAddress" class="font-weight-bold"></span>
                  <span style="padding-left:6px;">
                    <i class="far fa-copy"></i>
                  </span>
                </div>
              </center>
              <br>
              <center><img id="receiveQR" style="width: 25%;height:auto;image-rendering:pixelated;"></center>
            </div>
          </div>

        </div>
        <div class="col-2"></div>
      </div>

    </div>

    <div class="container marketing pt-navbar" id="authPage">
      <h4 class="mb-5 theme-color-secondary font-weight-bold">StakeCube 2FA</h4>

      <div class="row">
        <div class="col-2"></div>
        <div class="col-8">

          <div class="card card-prop mb-4">
            <div class="card-body">
              <div id="authTitle" class="card-title font-gray font-weight-bold">Setup your 2FA</div>
                <div class="alert alert-danger-custom" style="font-size:13px;">
                  <i class="fas fa-exclamation-triangle" style="margin-right: 6px;"></i>Do <b>not</b> share these codes with <b>anyone!</b>
                </div>
                <div class="alert alert-warning-custom" style="font-size:13px;">
                  <i class="fas fa-info-circle" style="margin-right: 6px;"></i> The 2FA screen can be used as an in-wallet 2FA app for your StakeCube.net account, if you haven't already setup 2FA on your StakeCube.net account, use this and secure your account with your wallet!<br><br>
                  To find your 2FA settings, login to StakeCube.net, visit your settings, and copy your 2FA "Secret", below the QR code, into the "Secret Code" section of this 2FA screen, then you're secured!
                </div><br>
                <div id="authImport">
                  <div class="omrs-input-group" style="width:100%;">
                    <label class="omrs-input-underlined">
                      <input required id="authSecretImport" type="text" autofocus>
                      <span class="omrs-input-label">2FA</span>
                    </label>
                  </div>
                  
                  <center><button onclick="import2FA()" style="margin-top: 10px;" class="btn btn-theme btn-layout">Import</button></center>
                  <br>
                </div>
                <center id="authDisplay">
                  <div onclick="copyToClipboard(document.getElementById('authCode').innerText, '2FA code')" class="refresh-button hover-darker">
                    <span id="authCode" style="font-size: x-large;" class="font-weight-bold"></span>
                    <i  style="padding-left:6px;" class="far fa-copy refresh-button"></i>
                  </div>
                  <p id="authTime" style="opacity: 0.8;">10 seconds left til next code</p>
                  <br>
                </center>
              <center id="authReset"><button onclick="remove2FA()" style="margin-top: 10px;" class="btn btn-danger btn-layout">Remove 2FA</button></center>
            </div>
          </div>

        </div>
        <div class="col-2"></div>
      </div>

    </div>

    <div class="container marketing pt-navbar" id="stakingPage">
      <h4 class="mb-5 theme-color-secondary font-weight-bold">SCP-2 Staking</h4>

      <center>
        <h3>Est. APR of <b id="stakingApy">---</b></h3>
      </center>
      <br>
      <div class="row">
        <div class="col-2"></div>
        <div class="col-8">

          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold" id="stakingTitle">Loading...</div>
              <br>
              <center>
                <p id="stakingSubtitle">Loading...</p>
                <h2 id="stakingRewards">...</h2>
                <p id="stakingRoi" style="opacity:0.5;"></p>
                <br>
                <button id="stakingRedeem" class="btn btn-layout btn-theme disabled" onclick="redeemTokens()">Claim Rewards</button>
              </center><br><br>
              
              <center><img src="qr.png" style="display: none;"></center>
            </div>
          </div>

        </div>
        <div class="col-2"></div>
      </div>

    </div>
    <i id="themeButton" onclick="loadNextTheme();" class="fas fa-sun" style="position: fixed; bottom: 10px; left: 10px; color: black; opacity: 0.5; cursor: pointer;"></i>
  </main>

  <script src="js/bootstrap.bundle.min.js"></script>
  <script src="js/select.js"></script>

</body>

</html>